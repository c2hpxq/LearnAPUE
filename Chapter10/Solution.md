# Ex10.1

响应一个信号后直接退出



# Ex10.5

仅依赖alarm，设置多个timer。

设计思路：

- 对外提供一个timer_set接口，用户设置n秒后触发某个handler
- 内部维护一个优先队列结构，存放触发的绝对时间。因为只能用alarm，每次加入新的时间后，都更新alarm时间为队列中的最小值-当前时间。
  - 可能碰到该值为负数，所以每次还要将expired的handler全都触发掉。
- 信号处理会从队列中取最小时间的handler，“主线程”会往队列里存东西：存放的时候，屏蔽SIGALRM，防止死锁。



# Ex10.6

类似6.828中的一个pingpong程序。

可以用上buffered IO中的相关功能

- 使用tmpfile创建一个临时文件，返回FILE指针
- 为了每次的计算结果对对方可见，用setbuf设置不缓存（否则，结果将是**各算各的**）

实现上的注意点是防止“死等”。一个trick是：宁可“出错”（指对方进程已经退出，发送失败）也要把通知发出去，也就是exit的时机放在TELL之后，就能保证不会出现死等的情形。

# Ex10.7

再调用一次kill可以设置进程返回值。

# Ex10.8

- euid用于权限检查
- ruid用于身份识别

从用途上来讲，接收signal的进程并不为发送者做权限检查，所以euid在这里并没有用处。

我们真正关心的是发送者的真实身份，所以ruid在这里适用。



# Ex10.9

最直接的方式是写一个模版来生成程序，略。

一个取巧但不一定portable的方式：

- 依赖signal number为连续整数，循环判断；
- 发现设置了某个信号后，利用psignal来输出对应的名称。

# Ex10.10

运行一段时间，检查log，发现tm_sec隔一段时间+1，有绕回。应该是时间误差的累积。

cron还没有使用过，对其了解是定时运行任务。为防止误差累积，可以运行一次计算一次距离下一个整分钟的时间。



# Ex10.11

通过setrlimit修改RLIMIT_FSIZE=1024，将限制进程可以创建的最大文件大小为1024B。

设置BUFFSIZE=100，那么最后一次只会写入24B。

在linux和macos下，signal handler都没有被调用。目前的**猜测**是：这2个系统中write的实现会对rlimit值进行检测，发现只允许再写24B时，就只写24B并返回，不会写100B来触发signal。

# Ex10.12

fwrite会被alarm中断，之后会继续执行。